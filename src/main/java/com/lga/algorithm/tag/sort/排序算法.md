

# 常见的排序算法

![排序算法](./img.png)


# 不同算法之间需要考虑的问题

- 比较次数和移动次数
- 排序是否原地（空间复杂度O（1））
- 排序是否稳定（稳定的排序可以保证有序性）


# 冒泡排序

> 相邻的两个元素两两比价，观察是否满足大小要求，不满足就进行交换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。
> 
> <span style="color:red">注意：当某次没有交换数据，说明就已经达到了完全有序状态</span>

<b>一次冒泡的过程如下:</b>

![一次冒泡](./img_1.png)

<b>多次冒泡后的结果：</b>

![一次冒泡](./img_2.png)

<b>代码示例：</b>
```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

<b>结论：</b>
- 原地的排序算法
- 稳定的排序算法
- 最好的情况下，只需要一次冒泡，时间复杂度O(n)。最坏的的时间复杂度O(n²)


# 插入排序
> 我们将数组中的数据分为两个区间，<b>已排序区间</b>和<b>未排序区间</b>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。


<b>插入过程：</b>
>插入排序也包含两种操作，一种是<b>元素的比较</b>，一种是<b>元素的移动</b>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

![插入排序算法](./img_3.png)

<b>代码示例：</b>

```java

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

<b>结论：</b>
- 原地的排序算法
- 稳定的排序算法
- 最好情况，已经是有序的，O(n)。最坏情况O(n²)


# 选择排序
> 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

<b>选择排序原理示意图：</b>
![选择排序算法](./img_4.png)

<b>结论：</b>
- 原地的排序算法
- 不稳定的排序算法
- 时间复杂度都是O(n²)


# 总结
![总结](./img_5.png)


